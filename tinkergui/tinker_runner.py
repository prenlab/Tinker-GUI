import os
import logging
import subprocess
import sys

logger = logging.getLogger(__name__)

class TinkerRunner:
    """Python wrapper to call tinker cmdline program
    """
    def __init__(self, wd='.', tinker_path="/path/to/tinker/bin/", timeout=300):
        self.wd = wd
        self.tinker_path = tinker_path
        self.timeout = timeout

    def call(self, program, cmd_args='', inter_inps='', envs='', pre_cmds='', expected_outfiles=(), custom_outfile_suffix=''):
        """example args:
        program='analyze'
        cmd_args='xxx.xyz -k xxxx.key' or 'xxx.xyz -k xxxx.key EP'
        inter_inps='EP\\n' or ''
        
        program='protein'
        cmd_args=''
        inter_inps='ala-ala\\n\\n/path/to/amoebabio18.prm\\nACE\\nALA\\nALA\\nNME\\n\\n\\n'

        envs='PATH=$PATH:/some/path/to/add'

        other args:
        expected_outfiles: a list of expected output filenames to be generated by the tinker program called. 
            this list is used to verify that the expected files were successfully created.
        custom_outfile_suffix: this suffix is used to name the output files. if not provided, use tinker's default.
        """
        # check tinker executable exists
        if not os.path.isfile(os.path.join(self.tinker_path, program)):
            program += ".x"
            if not os.path.isfile(os.path.join(self.tinker_path, program)):
                logger.error(f"Tinker executable {program[:-2]} or {program} not found in path {self.tinker_path}.")
                logger.error("Termination due to failed Tinker call.")
                sys.exit(1)
        
        pre_cmds = "&& " + pre_cmds if pre_cmds else ''
        cmd = f"cd {self.wd} {pre_cmds} && {envs} {self.tinker_path}/{program} {cmd_args}"
        proc = None
        try:
            proc = subprocess.Popen(
                cmd,
                shell=True,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            outs, errs = map(lambda x: x.decode(), proc.communicate(input=inter_inps.encode(), timeout=self.timeout))
        except Exception as e:
            outs, errs = "", str(e)
        finally:
            if proc:
                proc.kill()  # this is important to cleanup properly, e.g., release memory.

        logger.info(f"Called Tinker: {cmd} ; Interactive Inputs Used: '" + inter_inps.replace('\n', '\\n') + "'")
        if outs:
            logger.info(f"Output: \n{outs}")
        if errs:
            logger.error(f"Errors: \n{errs}")
            logger.error("Termination due to failed Tinker call.")
            sys.exit(1)
        # verify expected output files
        for fname in expected_outfiles:
            if not os.path.isfile(os.path.join(self.wd, os.path.basename(fname))):
                logger.error(f"Expected output file {fname} not found after Tinker call.")
                logger.error("Termination due to failed Tinker call.")
                sys.exit(1)

            # rename successful output files if custom suffix is provided
            if custom_outfile_suffix:
                base, ext = os.path.splitext(os.path.basename(fname))
                new_name = f"{base}{custom_outfile_suffix}{ext.rsplit('_', 1)[0]}"
                os.rename(os.path.join(self.wd, os.path.basename(fname)), os.path.join(self.wd, new_name))
        return outs

    # not used currently
    # def call_protein_shortcut(self, seq, file_name, param_file="/path/to/amoebabio18.prm", clear_wd=False):
    #     """example args:
    #     seq=['ACE', 'ALA', 'ALA', 'NME']
    #     file_name='ala-ala' 
    #     param_file="/path/to/amoebabio18.prm"
    #     """
    #     if clear_wd:
    #         assert clear_wd != '/'
    #         os.system(f"rm -rf {self.wd}/*")
    #     inter_inps = f'{file_name}\n\n{param_file}\n' + '\n'.join(seq) + '\n\n\n'
    #     outs, errs = self.call('protein', inter_inps=inter_inps)
    #     with open(f"{self.wd}/{file_name}.key", "w") as f:
    #         f.write(f"parameters {param_file}\n")
    #     return outs, errs

